//figure_frame.jsx  //Author: Walter Mulder - DNAklik  /** * @@@BUILDINFO@@@ figure_frame.jsx ! Version!  June 17 2019. * This script is an extension off FitAnchorToColumn v3 by Vinny*///FitAnchorToColumn v3 //Transform anchored objects in order to rescale them to make them fit column width, keeping proportions. //by Vinny /** * This script places  images referenced by impoted XML into object styles based on the XML code* Images are rescaled with the code from  FitAnchorToColumn v3* The standaard maximum width is the width of the text column, but it can be overwritten if the width is assigned in the XML* The figure element with figcaption is placed in a surounding Textframe* A check is made to avoid changes to already processed images, for if the XML is relouded or updated by the link* Check the information on Github and www.dnaklik.nl */ if (parseFloat(app.version) < 6)     main(); else     app.doScript(main, ScriptLanguage.JAVASCRIPT, undefined, UndoModes.ENTIRE_SCRIPT, "FitAnchorToColumn");   function main() {       if (app.documents.length > 0) {         var             myDoc = app.activeDocument,             docUnits = myDoc.viewPreferences.horizontalMeasurementUnits,             myFound;          var d=app.documents[0];        var myDoc=app.activeDocument;//"real" Root        var root=myDoc.xmlElements[0];//"real" Root of xml        var img = root.evaluateXPathExpression("//img");        var allGraphics = d.allGraphics;        if (d.objectStyles.itemByName( "img" ) == null) {                    newOblectStyle = d.objectStyles.add({ name: "img"});        };        for (var j = 0; j < img.length; j++) {             styleName = img[j].parent.markupTag.name;              if(!d.objectStyles.itemByName(styleName).isValid){                  if (d.objectStyles.itemByName(styleName) == null) {                            newOblectStyle = d.objectStyles.add({name:styleName});                };            };        };        var imgNr = Array();        for(var n=0; n<allGraphics.length; n++)  {              styleName = allGraphics[n].associatedXMLElement.parent.markupTag.name;            // determmen new images                    if ( allGraphics[n].parent.appliedObjectStyle.name == "[None]" ) {                   imgNr[n] = "new";                                  allGraphics[n].parent.anchoredObjectSettings.anchoredPosition = AnchorPosition.ANCHORED;                  //  apply  object styleName for new images                            if( styleName == "symbol" || styleName == "math" ) {                    allGraphics[n].parent.appliedObjectStyle= d.objectStyles.itemByName( styleName );                 }                else {                    allGraphics[n].parent.appliedObjectStyle= d.objectStyles.itemByName( "img");                };            };            else {                imgNr[n] = "old";             };        };                   app.findGrepPreferences = app.changeGrepPreferences = null;         app.findGrepPreferences.findWhat = "~a";         myFound = myDoc.findGrep();          for (i = 0; i < myFound.length; i++) {             if (typeof myFound[i].parentTextFrames[0] != "undefined") {                 image = myFound[i].allGraphics;                if ( imgNr [i] == "new" ) {                    for(var n=0;n<image.length;n++){                                             // determine scalling basesd on XML                                                styleName = image[n].associatedXMLElement.parent.markupTag.name;                        var type = "outline";                        var pageWidth = 1;                        var destWidth = 1;                        attr = image[n].associatedXMLElement.parent.xmlAttributes;                        for (var m = 0; m < attr.length; m++) {                            if ( attr[m].name == "type" && attr[m].value == "inline" ) {                                type = "inline";                                destWidth = 0.5 * pageWidth;                            };                        };                        img_attr = image[n].associatedXMLElement.xmlAttributes;                        for (var m = 0; m < img_attr.length; m++) {                            if ( img_attr[m].name == "width" ) {                                destWidth = img_attr[m].value/640 * pageWidth;                            };                        };                    };                           var                         columnWidth = myFound[i].parentTextFrames[0].textFramePreferences.textColumnFixedWidth,                         columnHeight = myFound[i].parentTextFrames[0].geometricBounds[2] - myFound[i].parentTextFrames[0].geometricBounds[0],                         myObjectWidth = myFound[i].pageItems[0].geometricBounds[3] - myFound[i].pageItems[0].geometricBounds[1],                         myObjectHeight = myFound[i].pageItems[0].geometricBounds[2] - myFound[i].pageItems[0].geometricBounds[0],                         myScaleFactor = ( columnWidth * destWidth ) / myObjectWidth,                         myScaleMatrix = app.transformationMatrices.add({                             horizontalScaleFactor: myScaleFactor,                             verticalScaleFactor: myScaleFactor                         })                       if (myObjectHeight * myScaleFactor == columnHeight) {                         return null;                     } else if (myObjectHeight * myScaleFactor < columnHeight) {                         if ( myScaleFactor < 1 ) {                            myFound[i].pageItems[0].transform(                                 CoordinateSpaces.INNER_COORDINATES,                                 AnchorPoint.TOP_LEFT_ANCHOR,                                 myScaleMatrix);                        }                    } else {                         if ( myScaleFactor < 1 ) {                                                myFound[i].pageItems[0].transform(                                 CoordinateSpaces.INNER_COORDINATES,                                 AnchorPoint.TOP_LEFT_ANCHOR,                                 myScaleMatrix                             );                             myFound[i].pageItems[0].resize(                                 CoordinateSpaces.INNER_COORDINATES,                                 AnchorPoint.CENTER_ANCHOR,                                 ResizeMethods.REPLACING_CURRENT_DIMENSIONS_WITH, [ResizeConstraints.KEEP_CURRENT_VALUE,                                     UnitValue(columnHeight + String(docUnits)).as('pt')                                 ]                             );                        }                    }                }            }         }         for(var n=0; n<allGraphics.length; n++)  {             if ( imgNr [n] == "new" ) {                styleName = allGraphics[n].associatedXMLElement.parent.markupTag.name;                 // add text frame for images with caption                if( styleName != "symbol" && styleName != "math" ) {                    var myObjectWidth = allGraphics[n].geometricBounds[3] - allGraphics[n].geometricBounds[1];                    var myObjectHeight = allGraphics[n].geometricBounds[2] - allGraphics[n].geometricBounds[0];                    var boxFrame = allGraphics[n].associatedXMLElement.parent.placeIntoInlineFrame([myObjectWidth, myObjectHeight]);                    boxFrame.fit(FitOptions.FRAME_TO_CONTENT);                    boxFrame.appliedObjectStyle = d.objectStyles.itemByName( styleName );                 }            }        };        app.findGrepPreferences = app.changeGrepPreferences = null;       } else {         alert("Open a document");     } } 