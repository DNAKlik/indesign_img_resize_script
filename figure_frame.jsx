//FitAnchorToColumn v8    //by Vinny // This script is an extension off FitAnchorToColumn v3 by Vinny// to apply objectstyles to images based on the imported XML// Version! June 23 2019.// figure_frame.jsx// Author: Walter Mulder - DNAklik // www.dnaklik.nl        if (parseFloat(app.version) < 6)        main();    else       app.doScript(main, ScriptLanguage.JAVASCRIPT, undefined, UndoModes.ENTIRE_SCRIPT, "FitAnchorToColumn");            function main() {        if (app.documents.length > 0) {            var                myDoc = app.activeDocument,              myFound,              startTime = Date.now();                        // make sure autoreflow is on          myDoc.textPreferences.properties = {            deleteEmptyPages:          true,            limitToMasterTextFrames:   true,            preserveFacingPageSpreads: true,        };                     var d=app.documents[0];        var myDoc=app.activeDocument;//"real" Root        var root=myDoc.xmlElements[0];//"real" Root of xml        var img = root.evaluateXPathExpression("//img");        var allGraphics = d.allGraphics;        if (d.objectStyles.itemByName( "img" ) == null) {                    newOblectStyle = d.objectStyles.add({ name: "img",                    enableFrameFittingOptions: true,                    frameFittingOptions: {                         autoFit: true,                        fittingOnEmptyFrame: EmptyFrameFittingOptions.FILL_PROPORTIONALLY                    }                }            );        };        for (var j = 0; j < img.length; j++) {             styleName = img[j].parent.markupTag.name;              if(!d.objectStyles.itemByName(styleName).isValid){                  if (d.objectStyles.itemByName(styleName) == null) {                            if( styleName == "symbol" || styleName == "math" ) {                        newOblectStyle = d.objectStyles.add({ name: styleName,                                                            enableFrameFittingOptions: true,                                                                frameFittingOptions: {                                     autoFit: true,                                    fittingOnEmptyFrame: EmptyFrameFittingOptions.FILL_PROPORTIONALLY                                }                            }                        );                    }                    else {                        newOblectStyle = d.objectStyles.add({ name: styleName,                                                       enableTextFrameAutoSizingOptions: true,                            enableTextWrapAndOthers: true,                            textWrapPreferences: { textWrapMode:TextWrapModes.CONTOUR},                            textFramePreferences: { autoSizingType: AutoSizingTypeEnum.HEIGHT_AND_WIDTH}                        });                    }                };            };        };        var imgNr = Array();        for(var n=0; n<allGraphics.length; n++)  {              styleName = allGraphics[n].associatedXMLElement.parent.markupTag.name;            // determmen new images                    if ( allGraphics[n].parent.appliedObjectStyle.name == "[None]" ) {                   imgNr[n] = "new";                                  allGraphics[n].parent.anchoredObjectSettings.anchoredPosition = AnchorPosition.ANCHORED;                  //  apply  object styleName for new images                            if( styleName == "symbol" || styleName == "math" ) {                    allGraphics[n].parent.appliedObjectStyle= d.objectStyles.itemByName( styleName );                 }                else {                    allGraphics[n].parent.appliedObjectStyle= d.objectStyles.itemByName( "img");                };            };            else {                imgNr[n] = "old";             };        };        // Let's transform all anchored objects into custom positioned objects            app.findGrepPreferences = app.changeGrepPreferences = null;           app.findGrepPreferences.findWhat = "~a"           var myFound = myDoc.findGrep();                       for (i = 0; i < myFound.length; i++) {                myFound[i].pageItems[0].anchoredObjectSettings.anchoredPosition = AnchorPosition.ANCHORED;            }                      //recompose document          myDoc.recompose();                app.menuActions.itemByName("$ID/Recompose all stories").invoke();              //then check size and transform              for (i = 0; i < myFound.length; i++) {                image = myFound[i].allGraphics;             if ( imgNr [i] == "new" ) {                for(var n=0;n<image.length;n++){                                         // determine scalling basesd on XML                                            styleName = image[n].associatedXMLElement.parent.markupTag.name;                    var type = "outline";                    var pageWidth = 1;                    var destWidth = 1;                    var scaleImg = 1;                    attr = image[n].associatedXMLElement.parent.xmlAttributes;                    for (var m = 0; m < attr.length; m++) {                        if ( attr[m].name == "type" && attr[m].value == "inline" ) {                            type = "inline";                            destWidth = 0.5 * pageWidth;                        };                    };                    img_attr = image[n].associatedXMLElement.xmlAttributes;                    for (var m = 0; m < img_attr.length; m++) {                        if ( img_attr[m].name == "width" ) {                            if( img_attr[m].value.substr(-1) == "%" ) {                                scaleImg = 0.5;                            }                            else {                                destWidth = img_attr[m].value/640 * pageWidth;                            }                        };                    };                };                                       var                        columnWidth = myFound[i].parentTextFrames[0].textFramePreferences.textColumnFixedWidth,                        columnHeight = myFound[i].parentTextFrames[0].geometricBounds[2] - myFound[i].parentTextFrames[0].geometricBounds[0],                        myObjectWidth = myFound[i].pageItems[0].geometricBounds[3] - myFound[i].pageItems[0].geometricBounds[1],                        myObjectHeight = myFound[i].pageItems[0].geometricBounds[2] - myFound[i].pageItems[0].geometricBounds[0],                        myScaleFactorH = ( columnWidth * destWidth ) / myObjectWidth,                        myScaleFactorV = ( columnHeight * destWidth ) / myObjectHeight,                        myScaleMatrixH = app.transformationMatrices.add({                            horizontalScaleFactor: myScaleFactorH,                            verticalScaleFactor: myScaleFactorH                        }),                        myScaleMatrixV = app.transformationMatrices.add({                            horizontalScaleFactor: myScaleFactorV,                            verticalScaleFactor: myScaleFactorV                        });                    myScaleMatrixScale = app.transformationMatrices.add({                            horizontalScaleFactor: scaleImg,                            verticalScaleFactor: scaleImg                        });                      if (myObjectWidth > columnWidth && myObjectHeight <= columnHeight) {                        myFound[i].pageItems[0].transform(                            CoordinateSpaces.INNER_COORDINATES,                            AnchorPoint.TOP_LEFT_ANCHOR,                            myScaleMatrixH);                        } else if (myObjectWidth < columnWidth && myObjectHeight > columnHeight) {                        myFound[i].pageItems[0].transform(                            CoordinateSpaces.INNER_COORDINATES,                            AnchorPoint.TOP_LEFT_ANCHOR,                            myScaleMatrixV);                        } else if (myObjectWidth > columnWidth && myObjectWidth / myObjectHeight > columnWidth / columnHeight) {                        myFound[i].pageItems[0].transform(                            CoordinateSpaces.INNER_COORDINATES,                            AnchorPoint.TOP_LEFT_ANCHOR,                            myScaleMatrixH);                        } else if (myObjectHeight > columnHeight && myObjectWidth / myObjectHeight < columnWidth / columnHeight) {                        myFound[i].pageItems[0].transform(                            CoordinateSpaces.INNER_COORDINATES,                            AnchorPoint.TOP_LEFT_ANCHOR,                            myScaleMatrixV);                                          } else {                        // nothing happens;                         if ( scaleImg != 1 ) {                        myFound[i].pageItems[0].transform(                            CoordinateSpaces.INNER_COORDINATES,                            AnchorPoint.TOP_LEFT_ANCHOR,                            myScaleMatrixScale);                     }                }             }        }                    // change back every anchor to inline  position                for (i = 0; i < myFound.length; i++) {                myFound[i].pageItems[0].anchoredObjectSettings.anchoredPosition = AnchorPosition.INLINE_POSITION;                // and (delete line below if not wanted), reset Y position to 0                myFound[i].pageItems[0].anchoredObjectSettings.anchorYoffset = 0;            }        for(var n=0; n<allGraphics.length; n++)  {             if ( imgNr [n] == "new" ) {                styleName = allGraphics[n].associatedXMLElement.parent.markupTag.name;                 // add text frame for images with caption                if( styleName != "symbol" && styleName != "math" ) {                    try {                         var myObjectWidth = allGraphics[n].parent.geometricBounds[3] - allGraphics[n].geometricBounds[1];                    } catch(err) {                        myObjectWidth = 100;                    }                    var boxFrame = allGraphics[n].associatedXMLElement.parent.placeIntoInlineFrame([myObjectWidth, 100]);                    boxFrame.appliedObjectStyle = d.objectStyles.itemByName( styleName);                }            }        };                alert("Script finished in "+ (Date.now() - startTime)+"ms. Now wait for autoreflow");      } else {            alert("Open a document");        }    } 