// figure_frame v3  // by Walter Mulder// This script is an extension off FitAnchorToColumn v8 by Vinny// to apply objectstyles to images based on the imported XML// Images are placed in a textframe figure together with their caption// Version! Sept 11 2019.// figure_frame.jsx// Author: Walter Mulder - DNAklik // www.dnaklik.nl        if (parseFloat(app.version) < 6)        main();    else       app.doScript(main, ScriptLanguage.JAVASCRIPT, undefined, UndoModes.ENTIRE_SCRIPT, "FitAnchorToColumn");            function main() {        if (app.documents.length > 0) {            var                myDoc = app.activeDocument,              myFound,              startTime = Date.now();                        // make sure autoreflow is on          myDoc.textPreferences.properties = {            deleteEmptyPages:          true,            limitToMasterTextFrames:   true,            preserveFacingPageSpreads: true,        };                     var org_page_width = 640; // used to correct widths given in pixels to percentage                var d=app.documents[0];        var myDoc=app.activeDocument;//"real" Root        var root=myDoc.xmlElements[0];//"real" Root of xml        var img = root.evaluateXPathExpression("//img");        var allGraphics = d.allGraphics;        if (d.objectStyles.itemByName( "img" ) == null) {                    newOblectStyle = d.objectStyles.add({ name: "img",                    enableFrameFittingOptions: true,                    frameFittingOptions: {                         autoFit: true,                        fittingOnEmptyFrame: EmptyFrameFittingOptions.FILL_PROPORTIONALLY                    }                }            );            // boxFrame.fit(FitOptions.FILL_PROPORTIONALLY)            //newOblectStyle.enableTextFrameAutoSizingOptions;        };        for (var j = 0; j < img.length; j++) {             styleName = img[j].parent.markupTag.name;              if(!d.objectStyles.itemByName(styleName).isValid){                  if (d.objectStyles.itemByName(styleName) == null) {                            if( styleName == "symbol" || styleName == "eq" ) {                        newOblectStyle = d.objectStyles.add({ name: styleName,                                                            enableFrameFittingOptions: true,                                                                frameFittingOptions: {                                     autoFit: true,                                    fittingOnEmptyFrame: EmptyFrameFittingOptions.FILL_PROPORTIONALLY                                }                            }                        );                    }                    else {                        newOblectStyle = d.objectStyles.add({ name: styleName,                                                       enableTextFrameAutoSizingOptions: true,                            enableTextWrapAndOthers: true,                            textWrapPreferences: { textWrapMode:TextWrapModes.CONTOUR},                            textFramePreferences: { autoSizingType: AutoSizingTypeEnum.HEIGHT_AND_WIDTH}                        });                    }                };            };        };        var imgNr = Array();        // Let's transform all anchored objects into custom positioned objects            app.findGrepPreferences = app.changeGrepPreferences = null;           app.findGrepPreferences.findWhat = "~a"           var myFound = myDoc.findGrep();         for (i = 0; i < myFound.length; i++) {                image = myFound[i].allGraphics;             for(var n=0;n<image.length;n++){                 styleName = image[n].associatedXMLElement.parent.markupTag.name;                // determmen new images                        if ( image[n].parent.appliedObjectStyle.name == "[None]" ) {                      imgNr[i] = "new";                                     image[n].parent.anchoredObjectSettings.anchoredPosition = AnchorPosition.ANCHORED;                     //  apply  object styleName for new images                               if( styleName == "symbol" || styleName == "eq" ) {                        image[n].parent.appliedObjectStyle= d.objectStyles.itemByName( styleName );                     }                    else {                        image[n].parent.appliedObjectStyle= d.objectStyles.itemByName( "img");                    };                };                else {                    imgNr[i] = "old";                 };            };            myFound[i].pageItems[0].anchoredObjectSettings.anchoredPosition = AnchorPosition.ANCHORED;           };                     //recompose document          myDoc.recompose();                app.menuActions.itemByName("$ID/Recompose all stories").invoke();              //then check size and transform             for (i = 0; i < myFound.length; i++) {                image = myFound[i].allGraphics;             if ( imgNr [i] == "new" ) {                for(var n=0;n<image.length;n++){                                         // determine scalling basesd on XML                          styleName = image[n].associatedXMLElement.parent.markupTag.name;                    var type = "outline";                    var pageWidth = 1;                    var destWidth = 1;                    var scaleImg = 1;                    attr = image[n].associatedXMLElement.parent.xmlAttributes;                    for (var m = 0; m < attr.length; m++) {                        if ( attr[m].name == "type" && attr[m].value == "inline" ) {                            type = "inline";                            destWidth = 0.5 * pageWidth;                        };                    };                    img_attr = image[n].associatedXMLElement.xmlAttributes;                    for (var m = 0; m < img_attr.length; m++) {                        if ( img_attr[m].name == "width" ) {                            // resize image based on width attribute in XML                            if( img_attr[m].value.substr(-1) == "%" ) {                                scaleImg = img_attr[m].value.substr(0, img_attr[m].value.length-1 )/100; // must be percentage                            }                            else {                                destWidth = img_attr[m].value/org_page_width * pageWidth;                            }                        };                    };                };                                       var                        columnWidth = myFound[i].parentTextFrames[0].textFramePreferences.textColumnFixedWidth,                        columnHeight = myFound[i].parentTextFrames[0].geometricBounds[2] - myFound[i].parentTextFrames[0].geometricBounds[0],                        myObjectWidth = myFound[i].pageItems[0].geometricBounds[3] - myFound[i].pageItems[0].geometricBounds[1],                        myObjectHeight = myFound[i].pageItems[0].geometricBounds[2] - myFound[i].pageItems[0].geometricBounds[0],                        myScaleFactorH = ( columnWidth * destWidth ) / myObjectWidth,                        myScaleFactorV = ( columnHeight * destWidth ) / myObjectHeight,                        myScaleMatrixH = app.transformationMatrices.add({                            horizontalScaleFactor: myScaleFactorH,                            verticalScaleFactor: myScaleFactorH                        }),                     myScaleMatrixV = app.transformationMatrices.add({                            horizontalScaleFactor: myScaleFactorV,                            verticalScaleFactor: myScaleFactorV                        });                    myScaleMatrixScale = app.transformationMatrices.add({                            horizontalScaleFactor: scaleImg,                            verticalScaleFactor: scaleImg                        });                if (myObjectWidth > columnWidth && myObjectHeight <= columnHeight) {                        myFound[i].pageItems[0].transform(                            CoordinateSpaces.INNER_COORDINATES,                            AnchorPoint.TOP_LEFT_ANCHOR,                            myScaleMatrixH);                        } else if (myObjectWidth < columnWidth && myObjectHeight > columnHeight) {                        myFound[i].pageItems[0].transform(                            CoordinateSpaces.INNER_COORDINATES,                            AnchorPoint.TOP_LEFT_ANCHOR,                            myScaleMatrixV);                        } else if (myObjectWidth > columnWidth && myObjectWidth / myObjectHeight > columnWidth / columnHeight) {                        myFound[i].pageItems[0].transform(                            CoordinateSpaces.INNER_COORDINATES,                            AnchorPoint.TOP_LEFT_ANCHOR,                            myScaleMatrixH);                        } else if (myObjectHeight > columnHeight && myObjectWidth / myObjectHeight < columnWidth / columnHeight) {                        myFound[i].pageItems[0].transform(                            CoordinateSpaces.INNER_COORDINATES,                            AnchorPoint.TOP_LEFT_ANCHOR,                            myScaleMatrixV);                                          } else {                        // nothing happens;                         if ( scaleImg != 1 ) {                        myFound[i].pageItems[0].transform(                            CoordinateSpaces.INNER_COORDINATES,                            AnchorPoint.TOP_LEFT_ANCHOR,                            myScaleMatrixScale);                     }                }             }        }            // change back every anchor to inline  position                for (i = 0; i < myFound.length; i++) {                myFound[i].pageItems[0].anchoredObjectSettings.anchoredPosition = AnchorPosition.INLINE_POSITION;                // and (delete line below if not wanted), reset Y position to 0                myFound[i].pageItems[0].anchoredObjectSettings.anchorYoffset = 0;            }        for(var n=0; n<allGraphics.length; n++)  {             if ( imgNr [n] == "new" ) {                styleName = allGraphics[n].associatedXMLElement.parent.markupTag.name;                 // add text frame for images with caption                if( styleName != "symbol" && styleName != "eq" ) {                    try {                         var myObjectWidth = allGraphics[n].parent.geometricBounds[3] - allGraphics[n].geometricBounds[1];                    } catch(err) {                        myObjectWidth = 100;                    }                    //var myObjectHeight = allGraphics[n].parent.geometricBounds[2] - allGraphics[n].geometricBounds[0];                     //alert(myObjectWidth+" "+myObjectHeight);                    var boxFrame = allGraphics[n].associatedXMLElement.parent.placeIntoInlineFrame([myObjectWidth, 100]);                    boxFrame.appliedObjectStyle = d.objectStyles.itemByName( styleName);                    //boxFrame.fit(FitOptions.FRAME_TO_CONTENT);                    //boxFrame.textWrapPreferences.textWrapMode = TextWrapModes.BOUNDING_BOX_TEXT_WRAP;                }            }        };                alert("Script finished in "+ (Date.now() - startTime)+"ms. Now wait for autoreflow");      } else {            alert("Open a document");        }    } 